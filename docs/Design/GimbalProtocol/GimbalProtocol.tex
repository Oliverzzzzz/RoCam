\documentclass[12pt, titlepage]{article}
\pdfinfoomitdate=1
\pdftrailerid{}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{bytefield}

\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Gimbal Protocol Specification for \progname{}}
\author{\authname}
\date{January 12, 2026}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes}   \\
  \midrule
  Jan. 12, 2026       & Rev 0         & Initial Draft \\
  \bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

\begin{tabularx}{\textwidth}{p{3cm}X}
  \toprule {\bf Term} & {\bf Definition}                                                               \\
  \midrule
  Host                & The controlling computer that sends commands to the gimbal                     \\
  Gimbal              & The motorized camera mount that receives commands and executes them            \\
  CRC                 & Cyclic Redundancy Check---a method for detecting errors in transmitted data    \\
  LED                 & Light Emitting Diode---a small indicator light                                 \\
  LE                  & Little-Endian---a byte ordering where the least significant byte comes first   \\
  IEEE-754            & International standard for floating-point arithmetic                           \\
  UART                & Universal Asynchronous Receiver-Transmitter---a serial communication interface \\
  \bottomrule
\end{tabularx}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

This document describes the serial communication protocol used between the host
computer and the gimbal device in \progname{}. The gimbal is a motorized mount
that controls the orientation of a camera, allowing it to tilt (move up and
down) and pan (move left and right).

The protocol is designed to be simple, reliable, and easy to implement. It uses
a serial connection (UART) to exchange small packets of data between the host
and the gimbal. Each packet includes error-checking information to ensure data
integrity.

This specification is intended for developers who need to implement or
understand the communication between the host software and the gimbal firmware.

\section{Physical Layer}

The protocol operates over a standard serial (UART) connection with the
following parameters:

\begin{table}[H]
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{Parameter} & \textbf{Value}         \\
    \midrule
    Baud Rate          & 115200 bits per second \\
    Data Bits          & 8                      \\
    Parity             & None                   \\
    Stop Bits          & 1                      \\
    Flow Control       & None                   \\
    \bottomrule
  \end{tabular}
  \caption{Serial Port Configuration}
\end{table}

The host computer connects to the gimbal using a serial port, typically named
\texttt{/dev/ttyUSB0}, \texttt{/dev/ttyACM0}, or \texttt{/dev/ttyTHS1} on Linux
systems.

\section{Communication Model}

\subsection{Request-Response Structure}

This protocol uses a strict \textbf{request-response} communication model. This
means:

\begin{enumerate}
  \item \textbf{All communication is initiated by the host.} The gimbal never sends data on its own---it only responds when asked.
  \item \textbf{Every request must receive a response.} When the host sends a command, it must wait for the gimbal to reply before sending another command.
  \item \textbf{One request, one response.} Each request from the host results in exactly one response from the gimbal.
\end{enumerate}

This model simplifies the protocol because neither side needs to handle
unexpected incoming data. The host always knows when to expect a response, and
the gimbal always knows that incoming data is a new command.

\begin{figure}[H]
  \centering
  \begin{verbatim}
    Host                          Gimbal
      |                             |
      |-------- Request ----------->|
      |                             |
      |<------- Response -----------|
      |                             |
      |-------- Request ----------->|
      |                             |
      |<------- Response -----------|
      |                             |
\end{verbatim}
  \caption{Request-Response Communication Flow}
\end{figure}

\subsection{Timing}

The host should wait for a response within a reasonable timeout period
(typically 500 milliseconds). If no response is received within this time, the
host should assume the command failed and may retry.

\section{Packet Structure}

All data exchanged between the host and gimbal is organized into
\textbf{packets}. A packet is a sequence of bytes with a defined structure.
Both request packets (from host to gimbal) and response packets (from gimbal to
host) follow specific formats.

\subsection{Byte Numbering Convention}

Throughout this document, bytes within a packet are numbered starting from 0.
For example, in a 3-byte packet:
\begin{itemize}
  \item Byte 0 is the first byte
  \item Byte 1 is the second byte
  \item Byte 2 is the third byte
\end{itemize}

When describing ranges, we use the notation \texttt{[start..end]}, which
includes both the start and end bytes. For example, \texttt{[2..5]} means bytes
2, 3, 4, and 5 (4 bytes total).

\subsection{Request Packet Format}

Request packets are sent from the host to the gimbal. Every request packet has
the following structure:

\begin{table}[H]
  \centering
  \begin{tabular}{ccl}
    \toprule
    \textbf{Byte Position} & \textbf{Size} & \textbf{Description}                             \\
    \midrule
    0                      & 1 byte        & CRC-8 checksum (covers bytes 1 through end)      \\
    1                      & 1 byte        & Command ID (identifies which command to execute) \\
    2..N                   & variable      & Payload (command-specific data, may be empty)    \\
    \bottomrule
  \end{tabular}
  \caption{Request Packet Structure}
\end{table}

\textbf{Key points:}
\begin{itemize}
  \item The minimum request packet size is 2 bytes (CRC + Command ID, with no payload).
  \item The CRC byte is calculated over all bytes \emph{after} itself (bytes 1 through
        the end of the packet).
  \item Different commands have different payload sizes, including zero (no payload).
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{bytefield}[bitwidth=1.5em]{24}
    \bitheader{0-23} \\
    \bitbox{8}{CRC} & \bitbox{8}{Command ID} & \bitbox{8}{Payload...}
  \end{bytefield}
  \caption{Request Packet Layout (sizes in bits, 8 bits = 1 byte)}
\end{figure}

\subsection{Response Packet Format}

Response packets are sent from the gimbal to the host. Every response packet
has the following structure:

\begin{table}[H]
  \centering
  \begin{tabular}{ccl}
    \toprule
    \textbf{Byte Position} & \textbf{Size} & \textbf{Description}                        \\
    \midrule
    0..N-1                 & variable      & Data (response-specific, may be empty)      \\
    N                      & 1 byte        & CRC-8 checksum (covers bytes 0 through N-1) \\
    \bottomrule
  \end{tabular}
  \caption{Response Packet Structure}
\end{table}

\textbf{Key points:}
\begin{itemize}
  \item The minimum response packet size is 1 byte (just the CRC, with no data).
  \item The CRC byte is the \emph{last} byte and is calculated over all preceding
        bytes.
  \item For commands that only need to confirm success (acknowledgment), the response
        contains 0 data bytes. In this case, the CRC is calculated over an empty
        sequence, which always equals \texttt{0x00}.
\end{itemize}

\begin{figure}[H]
  \centering
  \begin{bytefield}[bitwidth=1.5em]{24}
    \bitheader{0-23} \\
    \bitbox{16}{Data...} & \bitbox{8}{CRC}
  \end{bytefield}
  \caption{Response Packet Layout (sizes in bits, 8 bits = 1 byte)}
\end{figure}

\subsection{Acknowledgment Responses}

Many commands only need to indicate success or failure. For these commands, the
gimbal responds with a single byte: the CRC calculated over zero data bytes.

Since the CRC-8/SMBUS algorithm with no input data produces \texttt{0x00}, a
successful acknowledgment is simply:

\begin{table}[H]
  \centering
  \begin{tabular}{cc}
    \toprule
    \textbf{Byte 0} & \textbf{Meaning}            \\
    \midrule
    \texttt{0x00}   & Success (CRC of empty data) \\
    Any other value & Error                       \\
    \bottomrule
  \end{tabular}
  \caption{Acknowledgment Response}
\end{table}

\section{Error Detection: CRC-8/SMBUS}

To detect transmission errors (such as electrical noise corrupting data), both
request and response packets include a \textbf{CRC} (Cyclic Redundancy Check)
byte. This protocol uses the \textbf{CRC-8/SMBUS} algorithm.

\subsection{What is a CRC?}

A CRC is a small number calculated from a sequence of bytes using a
mathematical formula. The sender calculates the CRC and includes it in the
packet. The receiver recalculates the CRC from the received data and compares
it to the received CRC. If they match, the data is likely correct. If they
differ, an error occurred during transmission.

\subsection{CRC-8/SMBUS Parameters}

The CRC-8/SMBUS algorithm uses the following parameters:

\begin{table}[H]
  \centering
  \begin{tabular}{ll}
    \toprule
    \textbf{Parameter} & \textbf{Value}                                    \\
    \midrule
    Width              & 8 bits (produces a 1-byte result)                 \\
    Polynomial         & \texttt{0x07}                                     \\
    Initial Value      & \texttt{0x00}                                     \\
    Reflect Input      & No                                                \\
    Reflect Output     & No                                                \\
    XOR Output         & \texttt{0x00}                                     \\
    Check Value        & \texttt{0xF4} (CRC of ASCII string ``123456789'') \\
    \bottomrule
  \end{tabular}
  \caption{CRC-8/SMBUS Algorithm Parameters}
\end{table}

\subsection{CRC Calculation Example}

Here is a step-by-step description of the CRC calculation:

\begin{enumerate}
  \item Start with the CRC value set to \texttt{0x00}.
  \item For each byte in the data:
        \begin{enumerate}
          \item XOR the current CRC value with the byte.
          \item For each of the 8 bits in the byte:
                \begin{itemize}
                  \item If the highest bit of the CRC is 1, shift the CRC left by 1 and XOR with the
                        polynomial (\texttt{0x07}).
                  \item Otherwise, just shift the CRC left by 1.
                \end{itemize}
          \item Keep only the lowest 8 bits of the result.
        \end{enumerate}
  \item The final CRC value is the checksum.
\end{enumerate}

\textbf{Special case:} When calculating the CRC over zero bytes (empty data), the result is \texttt{0x00} because the initial value is \texttt{0x00} and no processing occurs.

\section{Data Types and Byte Order}

\subsection{Integer Values}

Single-byte integer values (such as Command ID or LED state) are unsigned 8-bit
integers with values from 0 to 255.

\subsection{Floating-Point Values}

Floating-point numbers are encoded using the \textbf{IEEE-754} format:
\begin{itemize}
  \item \textbf{Single-precision} (float32): 4 bytes (32 bits), used for angles
  \item \textbf{Double-precision} (float64): 8 bytes (64 bits), used for GPS coordinates
  \item Byte order: \textbf{Little-endian} (least significant byte first)
\end{itemize}

\textbf{Little-endian} means that when a multi-byte number is transmitted, the byte containing the smallest part of the value is sent first. For example, the number 12.5 as float32 is stored as the bytes \texttt{0x00 0x00 0x48 0x41} in memory on a little-endian system, and transmitted in that order.

\subsection{64-bit Integer Values}

64-bit unsigned integers (u64) are used for timestamps:
\begin{itemize}
  \item Size: 8 bytes (64 bits)
  \item Byte order: \textbf{Little-endian} (least significant byte first)
  \item Range: 0 to $2^{64}-1$
\end{itemize}

\section{Command Reference}

This section describes each command supported by the protocol. For each
command, we specify:
\begin{itemize}
  \item The Command ID (a number identifying the command)
  \item The request format (what the host sends)
  \item The response format (what the gimbal replies)
  \item The purpose of the command
\end{itemize}

\subsection{Command Summary}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{ccX}
    \toprule
    \textbf{Command ID} & \textbf{Name}  & \textbf{Description}                              \\
    \midrule
    \texttt{0x00}       & Set ARM LED    & Turn the ARM indicator LED on or off              \\
    \texttt{0x01}       & Set Status LED & Turn the Status indicator LED on or off           \\
    \texttt{0x02}       & Move           & Move the gimbal to a specified tilt and pan angle \\
    \texttt{0x03}       & Measure        & Read the current tilt and pan angles              \\
    \texttt{0x04}       & Get GPS Data   & Read the current GPS coordinates and timestamp    \\
    \texttt{0x05}       & Set Focal Length & Set the camera focal length in millimeters       \\
    \bottomrule
  \end{tabularx}
  \caption{Command Summary}
\end{table}

\subsection{Set ARM LED (Command ID: \texttt{0x00})}

\subsubsection{Purpose}
This command controls the ARM indicator LED on the gimbal. The ARM LED
typically indicates whether the gimbal is armed (ready to move) or disarmed
(safe to handle).

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value}                 & \textbf{Description}       \\
    \midrule
    0             & 1             & (calculated)                   & CRC-8 over bytes [1..2]    \\
    1             & 1             & \texttt{0x00}                  & Command ID                 \\
    2             & 1             & \texttt{0x00} or \texttt{0x01} & LED state: 0 = off, 1 = on \\
    \bottomrule
  \end{tabular}
  \caption{Set ARM LED Request (3 bytes total)}
\end{table}

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}                \\
    \midrule
    0             & 1             & \texttt{0x00}  & CRC-8 over 0 bytes (acknowledgment) \\
    \bottomrule
  \end{tabular}
  \caption{Set ARM LED Response (1 byte total)}
\end{table}

\subsubsection{Example}

To turn the ARM LED on:
\begin{itemize}
  \item Payload: \texttt{0x01} (on)
  \item Bytes to CRC: \texttt{0x00 0x01} (Command ID + payload)
  \item CRC result: \texttt{0x07}
  \item Complete request: \texttt{0x07 0x00 0x01}
  \item Expected response: \texttt{0x00}
\end{itemize}

\subsection{Set Status LED (Command ID: \texttt{0x01})}

\subsubsection{Purpose}
This command controls the Status indicator LED on the gimbal. The Status LED
can be used to indicate various system states, such as connection status or
error conditions.

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value}                 & \textbf{Description}       \\
    \midrule
    0             & 1             & (calculated)                   & CRC-8 over bytes [1..2]    \\
    1             & 1             & \texttt{0x01}                  & Command ID                 \\
    2             & 1             & \texttt{0x00} or \texttt{0x01} & LED state: 0 = off, 1 = on \\
    \bottomrule
  \end{tabular}
  \caption{Set Status LED Request (3 bytes total)}
\end{table}

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}                \\
    \midrule
    0             & 1             & \texttt{0x00}  & CRC-8 over 0 bytes (acknowledgment) \\
    \bottomrule
  \end{tabular}
  \caption{Set Status LED Response (1 byte total)}
\end{table}

\subsubsection{Example}

To turn the Status LED off:
\begin{itemize}
  \item Payload: \texttt{0x00} (off)
  \item Bytes to CRC: \texttt{0x01 0x00} (Command ID + payload)
  \item CRC result: \texttt{0x07}
  \item Complete request: \texttt{0x07 0x01 0x00}
  \item Expected response: \texttt{0x00}
\end{itemize}

\subsection{Move (Command ID: \texttt{0x02})}

\subsubsection{Purpose}
This command instructs the gimbal to move to a specified orientation. The
orientation is given as two angles:
\begin{itemize}
  \item \textbf{Tilt}: The vertical angle (up/down rotation)
  \item \textbf{Pan}: The horizontal angle (left/right rotation)
\end{itemize}

Both angles are specified in degrees as floating-point numbers.

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}    \\
    \midrule
    0             & 1             & (calculated)   & CRC-8 over bytes [1..9] \\
    1             & 1             & \texttt{0x02}  & Command ID              \\
    2..5          & 4             & (float32 LE)   & Tilt angle in degrees   \\
    6..9          & 4             & (float32 LE)   & Pan angle in degrees    \\
    \bottomrule
  \end{tabular}
  \caption{Move Request (10 bytes total)}
\end{table}

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}                \\
    \midrule
    0             & 1             & \texttt{0x00}  & CRC-8 over 0 bytes (acknowledgment) \\
    \bottomrule
  \end{tabular}
  \caption{Move Response (1 byte total)}
\end{table}

\subsubsection{Example}

To move to tilt = 0.0° and pan = 0.0° (center position):
\begin{itemize}
  \item Tilt (0.0 as float32 LE): \texttt{0x00 0x00 0x00 0x00}
  \item Pan (0.0 as float32 LE): \texttt{0x00 0x00 0x00 0x00}
  \item Bytes to CRC: \texttt{0x02 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}
  \item CRC result: \texttt{0x0E}
  \item Complete request: \texttt{0x0E 0x02 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}
  \item Expected response: \texttt{0x00}
\end{itemize}

\subsection{Measure (Command ID: \texttt{0x03})}

\subsubsection{Purpose}
This command requests the current orientation of the gimbal. The gimbal
responds with its current tilt and pan angles in degrees.

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}    \\
    \midrule
    0             & 1             & (calculated)   & CRC-8 over bytes [1..1] \\
    1             & 1             & \texttt{0x03}  & Command ID              \\
    \bottomrule
  \end{tabular}
  \caption{Measure Request (2 bytes total)}
\end{table}

Since there is no payload, the CRC is calculated over just the Command ID byte
(\texttt{0x03}), which results in \texttt{0x1B}.

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}          \\
    \midrule
    0..3          & 4             & (float32 LE)   & Current tilt angle in degrees \\
    4..7          & 4             & (float32 LE)   & Current pan angle in degrees  \\
    8             & 1             & (calculated)   & CRC-8 over bytes [0..7]       \\
    \bottomrule
  \end{tabular}
  \caption{Measure Response (9 bytes total)}
\end{table}

\subsubsection{Example}

Request to read current angles:
\begin{itemize}
  \item Bytes to CRC: \texttt{0x03}
  \item CRC result: \texttt{0x1B}
  \item Complete request: \texttt{0x1B 0x03}
\end{itemize}

Example response (tilt = 12.5°, pan = 3.25°):
\begin{itemize}
  \item Tilt (12.5 as float32 LE): \texttt{0x00 0x00 0x48 0x41}
  \item Pan (3.25 as float32 LE): \texttt{0x00 0x00 0x50 0x40}
  \item Data bytes: \texttt{0x00 0x00 0x48 0x41 0x00 0x00 0x50 0x40}
  \item CRC over data: \texttt{0xD9}
  \item Complete response: \texttt{0x00 0x00 0x48 0x41 0x00 0x00 0x50 0x40 0xD9}
\end{itemize}

\subsection{Get GPS Data (Command ID: \texttt{0x04})}

\subsubsection{Purpose}
This command requests the current GPS data from the gimbal. The gimbal responds
with its current longitude, latitude, and Unix timestamp in milliseconds. GPS
typically acquires time before coordinates. If coordinates are unknown, they are
returned as NaN (Not a Number). If the timestamp is unknown, it is returned as
zero.

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}    \\
    \midrule
    0             & 1             & (calculated)   & CRC-8 over bytes [1..1] \\
    1             & 1             & \texttt{0x04}  & Command ID              \\
    \bottomrule
  \end{tabular}
  \caption{Get GPS Data Request (2 bytes total)}
\end{table}

Since there is no payload, the CRC is calculated over just the Command ID byte
(\texttt{0x04}), which results in \texttt{0x0C}.

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}                    \\
    \midrule
    0..7          & 8             & (float64 LE)   & Longitude in degrees                    \\
    8..15         & 8             & (float64 LE)   & Latitude in degrees                     \\
    16..23        & 8             & (u64 LE)       & Unix timestamp in milliseconds          \\
    24            & 1             & (calculated)   & CRC-8 over bytes [0..23]                \\
    \bottomrule
  \end{tabular}
  \caption{Get GPS Data Response (25 bytes total)}
\end{table}

\textbf{Note:} The GPS may provide data in stages:
\begin{itemize}
  \item If coordinates are unknown, longitude and latitude are returned as NaN
        (IEEE-754 NaN value).
  \item If the timestamp is unknown, it is returned as zero.
  \item GPS typically acquires time before coordinates, so it is possible to have
        a valid timestamp with NaN coordinates.
\end{itemize}

\subsubsection{Example}

Request to read GPS data:
\begin{itemize}
  \item Bytes to CRC: \texttt{0x04}
  \item CRC result: \texttt{0x0C}
  \item Complete request: \texttt{0x0C 0x04}
\end{itemize}

Example response with full GPS lock (longitude = -79.9167°, latitude = 43.2567°, timestamp = 1705123456789 ms):
\begin{itemize}
  \item Longitude (-79.9167 as float64 LE): \texttt{0xCD 0xCC 0xCC 0xCC 0xCC 0x9C 0x4F 0xC0}
  \item Latitude (43.2567 as float64 LE): \texttt{0x33 0x33 0x33 0x33 0x33 0x33 0x4D 0x40}
  \item Timestamp (1705123456789 as u64 LE): \texttt{0x15 0xDE 0x29 0x09 0x8E 0x01 0x00 0x00}
  \item Data bytes: \texttt{0xCD 0xCC 0xCC 0xCC 0xCC 0x9C 0x4F 0xC0 0x33 0x33 0x33 0x33 0x33 0x33 0x4D 0x40 0x15 0xDE 0x29 0x09 0x8E 0x01 0x00 0x00}
  \item CRC over data: (calculated)
  \item Complete response: (data bytes + CRC byte)
\end{itemize}

Example response with time only (timestamp = 1705123456789 ms, coordinates unknown):
\begin{itemize}
  \item Longitude (NaN as float64 LE): \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F}
  \item Latitude (NaN as float64 LE): \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F}
  \item Timestamp (1705123456789 as u64 LE): \texttt{0x15 0xDE 0x29 0x09 0x8E 0x01 0x00 0x00}
  \item Data bytes: \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F 0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F 0x15 0xDE 0x29 0x09 0x8E 0x01 0x00 0x00}
  \item CRC over data: (calculated)
  \item Complete response: (data bytes + CRC byte)
\end{itemize}

Example response without GPS lock (no time, no coordinates):
\begin{itemize}
  \item Longitude (NaN as float64 LE): \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F}
  \item Latitude (NaN as float64 LE): \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F}
  \item Timestamp (0 as u64 LE): \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}
  \item Data bytes: \texttt{0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F 0x00 0x00 0x00 0x00 0x00 0x00 0xF8 0x7F 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00}
  \item CRC over data: (calculated)
  \item Complete response: (data bytes + CRC byte)
\end{itemize}

\subsection{Set Focal Length (Command ID: \texttt{0x05})}

\subsubsection{Purpose}
This command sets the camera focal length on the gimbal. The focal length is
specified in millimeters as a floating-point number.

\subsubsection{Request Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}    \\
    \midrule
    0             & 1             & (calculated)   & CRC-8 over bytes [1..5] \\
    1             & 1             & \texttt{0x05}  & Command ID              \\
    2..5          & 4             & (float32 LE)   & Focal length in mm      \\
    \bottomrule
  \end{tabular}
  \caption{Set Focal Length Request (6 bytes total)}
\end{table}

\subsubsection{Response Format}

\begin{table}[H]
  \centering
  \begin{tabular}{cccl}
    \toprule
    \textbf{Byte} & \textbf{Size} & \textbf{Value} & \textbf{Description}                \\
    \midrule
    0             & 1             & \texttt{0x00}  & CRC-8 over 0 bytes (acknowledgment) \\
    \bottomrule
  \end{tabular}
  \caption{Set Focal Length Response (1 byte total)}
\end{table}

\subsubsection{Example}

To set focal length to 50.0 mm:
\begin{itemize}
  \item Focal length (50.0 as float32 LE): \texttt{0x00 0x00 0x48 0x42}
  \item Bytes to CRC: \texttt{0x05 0x00 0x00 0x48 0x42} (Command ID + payload)
  \item CRC result: (calculated)
  \item Complete request: (CRC byte + Command ID + payload)
  \item Expected response: \texttt{0x00}
\end{itemize}

\section{Error Handling}

\subsection{CRC Mismatch}
If the receiver calculates a CRC that does not match the received CRC byte, the
packet should be considered corrupted. The host should:
\begin{enumerate}
  \item Discard the corrupted response
  \item Optionally retry the command
  \item Report an error if retries are exhausted
\end{enumerate}

\subsection{Timeout}
If the host does not receive a response within the timeout period (typically
500 ms), it should:
\begin{enumerate}
  \item Assume the command failed
  \item Optionally retry the command
  \item Report an error if retries are exhausted
\end{enumerate}

\subsection{Invalid Acknowledgment}
For commands expecting a single-byte acknowledgment (\texttt{0x00}), any other
value indicates an error. The host should treat this as a command failure.

\end{document}
